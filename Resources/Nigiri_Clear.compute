#pragma kernel CSMain0
#pragma kernel CSMain1
#pragma kernel CSMain2

RWTexture3D<half4> RG0;
RWTexture3D<half> RG0A;

uniform RWTexture3D<half4>			voxelCasacadeGrid1;
uniform RWTexture3D<half4>			voxelCasacadeGrid2;

//uniform RWStructuredBuffer<float3> RG1;
//uniform RWStructuredBuffer<uint>	lightMapBuffer;
uniform RWStructuredBuffer<uint>	voxelUpdateBuffer;

cbuffer cbSettings : register(b0)
{
	uint Resolution;
	uint zStagger;
	uniform float temporalStablityVsRefreshRate;
};

//http://graphicrants.blogspot.com/2009/04/rgbm-color-encoding.html
float4 RGBMEncode(float3 color) {
	//color = pow(color, 0.454545); // Convert Linear to Gamma
	float4 rgbm;
	color *= 1.0 / 6.0;
	rgbm.a = saturate(max(max(color.r, color.g), max(color.b, 1e-6)));
	rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
	rgbm.rgb = color / rgbm.a;
	return rgbm;
}

float3 RGBMDecode(float4 rgbm) {
	return 6.0 * rgbm.rgb * rgbm.a;
	//return pow(6.0 * rgbm.rgb * rgbm.a, 2.2); // Also converts Gamma to Linear
}
///

uint threeD2oneD(float3 coord)
{
	return coord.z * (Resolution * Resolution) + (coord.y * Resolution) + coord.x;
}


// 0 - Clear all
[numthreads(16, 16, 1)]
void CSMain0(uint3 id : SV_DispatchThreadID)
{
	for (uint i = 0; i < Resolution; i++)
	{
		RG0[uint3(id.xy, i)] = 0;
		RG0A[uint3(id.xy, i)] = 0;
	}
}


// 1 - Masks alpha
[numthreads(16, 16, 1)]
void CSMain1(uint3 id : SV_DispatchThreadID)
{
	for (uint i = 0; i < Resolution; i++)
	{
		uint index = threeD2oneD(uint3(id.xy, i));
		
		if (voxelUpdateBuffer[index] == 0)
		{
			if (RG0A[uint3(id.xy, i)] > 0)
			{
				//if (lightMapBuffer[index] == 0)
				//{
					RG0[uint3(id.xy, i)] = RGBMEncode(RGBMDecode(RG0[uint3(id.xy, i)]) * 0.9);
					RG0A[uint3(id.xy, i)] *= 0.9;
					//voxelCasacadeGrid1[uint3(id.xy, i)] *= temporalStablityVsRefreshRate;
					//voxelCasacadeGrid2[uint3(id.xy, i)] *= temporalStablityVsRefreshRate;
				//}
				//lightMapBuffer[index] = 0;
			}
		}
		/*else if (voxelUpdateBuffer[index] == 1)
		{
			RG0[uint3(id.xy, i)].rgba *= 0.9;
		}*/
		voxelUpdateBuffer[index] = 0;

		uint Resolution2 = Resolution * 0.5f;
		if (i < Resolution2 && id.x < Resolution2 && id.y < Resolution2)
		{
			if (voxelCasacadeGrid1[uint3(id.xy, i)].a > 0)
			{
				voxelCasacadeGrid1[uint3(id.xy, i)] *= (temporalStablityVsRefreshRate * 0.9);
			}
		}
		uint Resolution3 = Resolution * 0.25f;
		if (i < Resolution3 && id.x < Resolution3 && id.y < Resolution3)
		{
			if (voxelCasacadeGrid2[uint3(id.xy, i)].a > 0)
			{
				voxelCasacadeGrid2[uint3(id.xy, i)] *= (temporalStablityVsRefreshRate * 0.9);
			}
		}
	}
}

// 2 - Clear Buffer
[numthreads(1024, 1, 1)]
void CSMain2(uint3 id : SV_DispatchThreadID)
{
	voxelUpdateBuffer[id.x] = 0;
}
