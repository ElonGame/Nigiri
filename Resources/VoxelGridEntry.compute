// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Readable/Writable texture for storing the direct lighting and the occupied flag
RWTexture3D<float4>			voxelGrid;

// Texture for storing the color with direct lighting
Texture2D<float4>			lightingTexture;

Texture2D<float4>			lightMapTexture;

// Texture for storing the world space position
Texture2D<float4>			positionTexture;

Texture2D<float4>			NoiseTexture;

// Variable representing the dimension of the voxel grid
uint						voxelResolution;

// World-space boundary of the voxel grid
float 						worldVolumeBoundary;

float f0;
uint rng_state;
double checkCounter;

// Function to get position of voxel in the grid
inline uint3 GetVoxelPosition (float3 worldPosition)
{
	float3 encodedPosition = worldPosition / worldVolumeBoundary;
	encodedPosition += float3(1.0f, 1.0f, 1.0f);
	encodedPosition /= 2.0f;
	uint3 voxelPosition = (uint3)(encodedPosition * voxelResolution);
	return voxelPosition;
}

float2 rand(float2 coord)
{
	float noiseX = saturate(frac(sin(dot(coord, float2(12.9898, 78.223))) * 43758.5453));
	float noiseY = saturate(frac(sin(dot(coord, float2(12.9898, 78.223)*2.0)) * 43758.5453));

	return float2(noiseX, noiseY);
}

uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}


[numthreads(16, 16, 1)]
// Entry point of the voxelization compute shader
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float3 noiseCoord = NoiseTexture[id.xy].rgb;

	// Color of the current voxel with lighting
	float3 lightingColor = lightingTexture[id.xy + noiseCoord.rg].rgb;

	//float4 lightMapColor = lightMapTexture[id.xy] * 0.05;

	// World space position
	float3 worldPosition = positionTexture[id.xy + noiseCoord.rg].rgb;

	// Extract the pixel's depth
	float lindepth = positionTexture[id.xy + noiseCoord.rg].a;

	uint3 voxelPosition = GetVoxelPosition(worldPosition) + noiseCoord;

	f0 += 0.01f;

	// Inject the current voxel's information into the grid
	if (((lindepth < voxelGrid[voxelPosition].a) && (lindepth > 0.01f)) || (voxelGrid[voxelPosition].a == 0.0f))
	{

		voxelGrid[voxelPosition] = lerp(float4(lightingColor, lindepth), voxelGrid[voxelPosition], 0.5);
	}
	else if (f0 > noiseCoord.x)
	{
		voxelGrid[voxelPosition] = lerp(float4(lightingColor, lindepth), voxelGrid[voxelPosition], 0.5);
		f0 = 0;
	}

}