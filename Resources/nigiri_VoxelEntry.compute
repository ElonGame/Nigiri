#define LUMA_THRESHOLD_FACTOR 0.001f // Higher = higher accuracy with higher flickering
#define LUMA_DEPTH_FACTOR 100.0f 	// Higher = lesser variation with depth
#define LUMA_FACTOR 1.9632107f

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform RWTexture3D<half4>			voxelGrid;
uniform RWTexture3D<half>			voxelGridA
;
uniform RWTexture3D<half4>			voxelCasacadeGrid1;
uniform RWTexture3D<half4>			voxelCasacadeGrid2;

//uniform Texture3D<float4>			voxelInjectionGrid;
//uniform RWStructuredBuffer<uint>	lightMapBuffer;
uniform RWStructuredBuffer<uint>	voxelUpdateBuffer : register(u1);

cbuffer cbSettings : register(b0)
{
	uniform int						useDepth;
	uniform int						injectionTextureResolutionX;
	uniform int						nearestNeighbourPropagation;
	uniform uint					voxelResolution;
	uniform float3					gridOffset;
	uniform float 					worldVolumeBoundary;
	uniform float					shadowStrength;
	uniform float					sunLightInjection;
	uniform float					occlusionGain;
	uniform float					EmissiveStrength;
	uniform float					temporalStablityVsRefreshRate;
	

	uniform Texture2D<float>			depthTexture;
	uniform Texture2D<half4>			lightingTexture;
	uniform Texture2D<half4>			lightingTexture2;

	//uniform Texture2D<float4>			volumeLightTexture;

	uniform Texture2D<float4>			positionTexture;
	//uniform Texture2D<float4>			orthographicPositionTexture;
	//uniform Texture2D<float4>			depthTexture;
};

//http://graphicrants.blogspot.com/2009/04/rgbm-color-encoding.html
float4 RGBMEncode(float3 color) {
	//color = pow(color, 0.454545); // Convert Linear to Gamma
	float4 rgbm;
	color *= 1.0 / 6.0;
	rgbm.a = saturate(max(max(color.r, color.g), max(color.b, 1e-6)));
	rgbm.a = ceil(rgbm.a * 255.0) / 255.0;
	rgbm.rgb = color / rgbm.a;
	return rgbm;
}

float3 RGBMDecode(float4 rgbm) {
	return 6.0 * rgbm.rgb * rgbm.a;
	//return pow(6.0 * rgbm.rgb * rgbm.a, 2.2); // Also converts Gamma to Linear
}
///

// M matrix, for encoding
const static float3x3 M = float3x3(
	0.2209, 0.3390, 0.4184,
	0.1138, 0.6780, 0.7319,
	0.0102, 0.1130, 0.2969);

// Inverse M matrix, for decoding
const static float3x3 InverseM = float3x3(
	6.0014, -2.7008, -1.7996,
	-1.3320, 3.1029, -5.7721,
	0.3008, -1.0882, 5.6268);

float4 LogLuvEncode(in float3 vRGB) {
	float4 vResult;
	float3 Xp_Y_XYZp = mul(vRGB, M);
	Xp_Y_XYZp = max(Xp_Y_XYZp, float3(1e-6, 1e-6, 1e-6));
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2 * log2(Xp_Y_XYZp.y) + 127;
	vResult.w = frac(Le);
	vResult.z = (Le - (floor(vResult.w*255.0f)) / 255.0f) / 255.0f;
	return vResult;
}

float3 LogLuvDecode(in float4 vLogLuv) {
	float Le = vLogLuv.z * 255 + vLogLuv.w;
	float3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2((Le - 127) / 2);
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
	Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
	float3 vRGB = mul(Xp_Y_XYZp, InverseM);
	return max(vRGB, 0);
}
///

#define unity_ColorSpaceLuminance half4(0.0396819152, 0.458021790, 0.00609653955, 1.0)

// Function to get position of voxel in the grid
inline uint4 GetVoxelPosition(float4 worldPosition)
{
	//worldPosition.xyz = worldPosition.xyz - gridOffset.xyz;

	// What do I know?
	// Worldspace position of pixel
	// boundary
	// grid offset
	// depth
	uint cascade = 3;
	float cascade1 = 0.33;
	float cascade2 = 0.66;
	float cascade3 = 1.00;
	uint cachedResolution = voxelResolution;
	int cascadeBoundary = worldVolumeBoundary;
	int cascadeBoundary1 = worldVolumeBoundary * cascade1;
	int cascadeBoundary2 = worldVolumeBoundary * cascade2;
	int cascadeBoundary3 = worldVolumeBoundary * cascade3;

	if ((abs(worldPosition.x) < cascadeBoundary1) && (abs(worldPosition.y) < cascadeBoundary1) && (abs(worldPosition.z) < cascadeBoundary1))
	{
		cascade = 1;
		//cachedResolution = voxelResolution;
		cascadeBoundary = cascadeBoundary1;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary2) && (abs(worldPosition.y) < cascadeBoundary2) && (abs(worldPosition.z) < cascadeBoundary2))
	{
		cascade = 2;
		cachedResolution /= 2;
		cascadeBoundary = cascadeBoundary2;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary3) && (abs(worldPosition.y) < cascadeBoundary3) && (abs(worldPosition.z) < cascadeBoundary3))
	{
		cachedResolution /= 4;
		cascade = 3;
		cascadeBoundary = cascadeBoundary3;
	}
	else cascade = 4;
	
	float3 encodedPosition = worldPosition.xyz / cascadeBoundary;
	   	 
	encodedPosition += float3(1.0f, 1.0f, 1.0f);
	encodedPosition /= 2.0f;

	uint3 voxelPosition = (uint3)(encodedPosition * cachedResolution);

	return float4(voxelPosition.xyz, cascade);
}

inline uint3 coordinateFromLinearIndex(uint index, uint res)
{
	return uint3(
		floor(index / (res * res)),
		floor((index / res) % res),
		index % res);
}

inline uint3 index1dTo3d(int index1d)
{
	//int res = 256; // resolution of the voxel grid
	int logRes = 8; // the log of the resolution (just a performance optimisation this way)
	// LogRes: 16 = 4, 32 = 5, 64 = 6, 128 = 7, 256 = 8, 512 = 9, etc...

	return uint3(index1d >> (logRes << 1),
		(index1d >> logRes) & (voxelResolution - 1),
		index1d & (voxelResolution - 1));
}

uint threeD2oneD(float3 coord)
{
	return coord.z * (voxelResolution * voxelResolution) + (coord.y * voxelResolution) + coord.x;
}

inline float GetLuma(float3 inputColor)
{
	return ((inputColor.y * LUMA_FACTOR) + inputColor.x);
}

float rnd(uint2 x)
{
	int n = int(x.x * 40.0 + x.y * 6400.0);
	n = (n << 13) ^ n;
	return 1.0 - float((n * (n * n * 15731 + 789221) + \
		1376312589) & 0x7fffffff) / 1073741824.0;
}

// 0
[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
	float3 offsets[16] =
	{
		float3(1, 0, 0),
		float3(-1, 0, -0),
		float3(0, 1, 0),
		float3(0, -1, 0),
		float3(0, 0, 1),
		float3(0, 0, -1),
		float3(1, 1, 0),
		float3(1, -1, -0),
		float3(-1, 1, 0),
		float3(-1, -1, -0),
		float3(1, 0, 1),
		float3(1, 0, -1),
		float3(0, 1, 1),
		float3(0, 1, -1),
		float3(0, -1, 1),
		float3(0, -1, -1)
	};

	uint4 voxelPosition = GetVoxelPosition(positionTexture[id.xy]);
	uint index = threeD2oneD(voxelPosition.xyz);
	uint cascadeBoundary0 = voxelResolution * 0.25;
	uint cascadeBoundary1 = voxelResolution * 0.66;

	float depth = 0;
	if (useDepth)
	{
		float f = 50.0;
		float n = 0.3;

		depth = (2 * n) / (f + n - depthTexture[id.xy] * (f - n));
		//depth = depthTexture[id.xy];
	}
	else depth = positionTexture[id.xy].a;

	//float4 newMixedColor = (0).xxxx;
	//if ((depth < voxelUpdateBuffer[index].y) || (voxelUpdateBuffer[index].y == 0.0f))
	//{
	if (voxelPosition.w == 1)
	{
		//voxelGrid[voxelPosition.xyz] *= temporalStablityVsRefreshRate;

		half4 oldColor = voxelGrid[voxelPosition.xyz];

		half4 newMixedColor = (0).xxxx;
		if (nearestNeighbourPropagation == 1)
		{
			uint count = 1;
			half4 mixedColor = oldColor;

			for (int x = 0; x < 16; x++)
			{
				float3 offset = offsets[x];
				half4 testColor = voxelGrid[float3(voxelPosition.xyz + offset.xyz)];
				if (testColor.a > 0.1)
				{
					mixedColor += testColor;
					count++;
				}
			}
			mixedColor /= count;

			newMixedColor =
				half4((max(lightingTexture[id.xy].rgb, lightingTexture2[id.xy].rgb * (1 - shadowStrength).xxx)),
					lightingTexture2[id.xy].a * occlusionGain);

			newMixedColor = lerp(newMixedColor, mixedColor, 0.5);
		}
		else
		{
			//newMixedColor =
			//	float4(lightingTexture[id.xy].rgb * 0.25 + (DecodeRGBAuint(lightMapBuffer[index]).rgb * emissiveIntensity) +
			//	(lightingTexture2[id.xy].rgb * 0.25 * (1 - shadowStrength).xxx),
			//		lightingTexture2[id.xy].a * occlusionGain);

			newMixedColor =
				half4((max(lightingTexture[id.xy].rgb, lightingTexture2[id.xy].rgb * (1 - shadowStrength).xxx)),
					lightingTexture2[id.xy].a * occlusionGain);

			newMixedColor = lerp(newMixedColor, oldColor, 0.5);
			//newMixedColor = max(newMixedColor, voxelGrid[voxelPosition.xyz]);
		}

		float lumaThreshold = LUMA_THRESHOLD_FACTOR * (1.0f / depth * LUMA_DEPTH_FACTOR, 0.1f);
		float pixelLuma = GetLuma(newMixedColor.rgb);
		float currentVoxelLuma = GetLuma(oldColor.rgb);
		float lumaDiff = saturate(currentVoxelLuma - pixelLuma);
		float lumaDiff2 = saturate((currentVoxelLuma + pixelLuma) * 0.5);

		//float redDiff = abs(saturate(voxelGrid[voxelPosition.xyz].r - newMixedColor.r));
		//float greenDiff = abs(saturate(voxelGrid[voxelPosition.xyz].g - newMixedColor.g));
		//float blueDiff = abs(saturate(voxelGrid[voxelPosition.xyz].b - newMixedColor.b));

		float redDiff2 = saturate((oldColor.r + newMixedColor.r) * 0.5);
		float greenDiff2 = saturate((oldColor.g + newMixedColor.g) * 0.5);
		float blueDiff2 = saturate((oldColor.b + newMixedColor.b) * 0.5);

		/*if (lumaDiff < lumaThreshold)
		{
			//newMixedColor = max(newMixedColor, voxelGrid[voxelPosition.xyz]);
			voxelGrid[voxelPosition.xyz] = newMixedColor;
			//lerp(newMixedColor, voxelGrid[voxelPosition.xyz], 0.99);
		}
		else*/
		if (redDiff2 > lumaThreshold || greenDiff2 > lumaThreshold || blueDiff2 > lumaThreshold)
		{
			uint index = threeD2oneD(voxelPosition.xyz);
			if (voxelUpdateBuffer[index] == 0)
			{
				voxelGrid[voxelPosition.xyz] =
					lerp(newMixedColor, oldColor, 0.9);

				voxelGridA[voxelPosition.xyz] = 1;
				//	lerp(newMixedColor.a, oldColor.a, 0.9);
			}
			else
			{
				voxelGrid[voxelPosition.xyz] =
					lerp(newMixedColor, oldColor, 0.99);

				voxelGridA[voxelPosition.xyz] = 1;
				//voxelGridA[voxelPosition.xyz] =
				//	lerp(newMixedColor.a, oldColor.a, 0.99);
			}
		}
		/*else if (lumaDiff < lumaThreshold)
		{
			//newMixedColor = max(newMixedColor, voxelGrid[voxelPosition.xyz]);
			voxelGrid[voxelPosition.xyz] = newMixedColor;
			//lerp(newMixedColor, voxelGrid[voxelPosition.xyz], 0.99);
		}*/

		voxelUpdateBuffer[index] = 1;
	}
	else if(voxelPosition.w == 2)
	{
		voxelCasacadeGrid1[voxelPosition.xyz] *= temporalStablityVsRefreshRate;

		half4 newMixedColor =
			half4((max(lightingTexture[id.xy].rgb, lightingTexture2[id.xy].rgb * (1 - shadowStrength).xxx)),
				lightingTexture2[id.xy].a * occlusionGain);

		newMixedColor = lerp(newMixedColor, voxelCasacadeGrid1[voxelPosition.xyz], 0.5);

		float lumaThreshold = LUMA_THRESHOLD_FACTOR * (1.0f / depth * LUMA_DEPTH_FACTOR, 0.1f);
		float pixelLuma = GetLuma(newMixedColor.rgb);
		float currentVoxelLuma = GetLuma(voxelCasacadeGrid1[voxelPosition.xyz].rgb);
		float lumaDiff = abs(saturate(currentVoxelLuma - pixelLuma));

		float redDiff = abs(saturate(voxelCasacadeGrid1[voxelPosition.xyz].r - newMixedColor.r));
		float greenDiff = abs(saturate(voxelCasacadeGrid1[voxelPosition.xyz].g - newMixedColor.g));
		float blueDiff = abs(saturate(voxelCasacadeGrid1[voxelPosition.xyz].b - newMixedColor.b));

		if (lumaDiff < lumaThreshold)
		{
			voxelCasacadeGrid1[voxelPosition.xyz] = newMixedColor;
		}
	}
	else if (voxelPosition.w == 3)
	{
		voxelCasacadeGrid2[voxelPosition.xyz] *= temporalStablityVsRefreshRate;

		half4 newMixedColor =
			half4((max(lightingTexture[id.xy].rgb, lightingTexture2[id.xy].rgb * (1 - shadowStrength).xxx)),
				lightingTexture2[id.xy].a * occlusionGain);

		newMixedColor = lerp(newMixedColor, voxelCasacadeGrid2[voxelPosition.xyz], 0.5);

		float lumaThreshold = LUMA_THRESHOLD_FACTOR * (1.0f / depth * LUMA_DEPTH_FACTOR, 0.1f);
		float pixelLuma = GetLuma(newMixedColor.rgb);
		float currentVoxelLuma = GetLuma(voxelCasacadeGrid2[voxelPosition.xyz].rgb);
		float lumaDiff = abs(saturate(currentVoxelLuma - pixelLuma));

		float redDiff = abs(saturate(voxelCasacadeGrid2[voxelPosition.xyz].r - newMixedColor.r));
		float greenDiff = abs(saturate(voxelCasacadeGrid2[voxelPosition.xyz].g - newMixedColor.g));
		float blueDiff = abs(saturate(voxelCasacadeGrid2[voxelPosition.xyz].b - newMixedColor.b));

		if (lumaDiff < lumaThreshold)
		{
			voxelCasacadeGrid2[voxelPosition.xyz] = newMixedColor;
		}
	}
	//voxelUpdateBuffer[index] = 1;
}

	