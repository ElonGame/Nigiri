// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform RWTexture3D<float4>			voxelGrid;
uniform RWStructuredBuffer<uint>	lightMapBuffer;

inline uint3 CoordinateFromLinearIndex(uint index, uint res)
{
	return uint3(
		index % res,
		floor((index / res) % res),
		floor(index / (res * res)));
}

float3 hsv2rgb(float3 c)
{
	float4 k = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + k.xyz) * 6.0 - k.www);
	return c.z * lerp(k.xxx, saturate(p - k.xxx), c.y);
}

float4 DecodeRGBAuint(uint value)
{
	uint ai = value & 0x0000007F;
	uint vi = (value / 0x00000080) & 0x000007FF;
	uint si = (value / 0x00040000) & 0x0000007F;
	uint hi = value / 0x02000000;

	float h = float(hi) / 127.0;
	float s = float(si) / 127.0;
	float v = (float(vi) / 2047.0) * 10.0;
	float a = ai * 2.0;

	v = pow(v, 3.0);

	float3 color = hsv2rgb(float3(h, s, v));

	return float4(color.rgb, a);
}

// Entry point of the voxelization compute shader
[numthreads(256, 1, 1)]
void CSMain(uint3 id3 : SV_DispatchThreadID)
{
	voxelGrid[CoordinateFromLinearIndex(id3.x, 256)] = DecodeRGBAuint(lightMapBuffer[id3.x]);
	lightMapBuffer[id3.x] = 0;
}