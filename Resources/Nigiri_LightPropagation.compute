#pragma kernel CSMain
#pragma kernel CSMain1
#pragma kernel CSMain2

uniform RWTexture3D<float4> RG0;
uniform RWTexture3D<float4> RG1;

uniform uint						offsetStart;
uniform uint						highestVoxelResolution;
uniform float						LPVInverseFalloff;

uniform float4						_Time;

uniform uint Resolution;
uniform uint zStagger;

uint rng_state;

uint rand_lcg()
{
	// LCG values from Numerical Recipes
	rng_state = 1664525 * rng_state + 1013904223;
	return rng_state;
}

uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

uint wang_hash(uint seed)
{
	seed = (seed ^ 61) ^ (seed >> 16);
	seed *= 9;
	seed = seed ^ (seed >> 4);
	seed *= 0x27d4eb2d;
	seed = seed ^ (seed >> 15);
	return seed;
}

inline float3 rgb2hsv(float3 c)
{
	float4 k = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, k.wz), float4(c.gb, k.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;

	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float3 hsv2rgb(float3 c)
{
	float4 k = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + k.xyz) * 6.0 - k.www);
	return c.z * lerp(k.xxx, saturate(p - k.xxx), c.y);
}

inline float4 DecodeRGBAuint(uint value)
{
	uint ai = value & 0x0000007F;
	uint vi = (value / 0x00000080) & 0x000007FF;
	uint si = (value / 0x00040000) & 0x0000007F;
	uint hi = value / 0x02000000;

	float h = float(hi) / 127.0;
	float s = float(si) / 127.0;
	float v = (float(vi) / 2047.0) * 10.0;
	float a = ai * 2.0;

	v = pow(v, 3.0);

	float3 color = hsv2rgb(float3(h, s, v));

	return float4(color.rgb, a);
}

inline uint EncodeRGBAuint(float4 color)
{
	//7[HHHHHHH] 7[SSSSSSS] 11[VVVVVVVVVVV] 7[AAAAAAAA]
	float3 hsv = rgb2hsv(color.rgb);
	hsv.z = pow(hsv.z, 1.0 / 3.0);

	uint result = 0;

	uint a = min(127, uint(color.a / 2.0));
	uint v = min(2047, uint((hsv.z / 10.0) * 2047));
	uint s = uint(hsv.y * 127);
	uint h = uint(hsv.x * 127);

	result += a;
	result += v * 0x00000080; // << 7
	result += s * 0x00040000; // << 18
	result += h * 0x02000000; // << 25

	return result;
}

inline uint3 coordinateFromLinearIndex(uint index, uint res)
{
	return uint3(
		floor(index / (res * res)),
		floor((index / res) % res),
		index % res);
}

inline uint3 index1dTo3d(int index1d, uint res)
{
	//int res = 256; // resolution of the voxel grid
	int logRes = 8; // the log of the resolution (just a performance optimisation this way)
	// LogRes: 16 = 4, 32 = 5, 64 = 6, 128 = 7, 256 = 8, 512 = 9, etc...

	return uint3(index1d >> (logRes << 1),
		(index1d >> logRes) & (res - 1),

		index1d & (res - 1));
}

// 0

[numthreads(256, 1, 1)]
void CSMain(uint3 id3 : SV_DispatchThreadID)
{
	//rng_state = id3.x * _Time;
	//float f0 = float(rand_lcg()) * (1.0 / 4294967296.0);

	//if (f0 > 0.1f )//&& f0 < 0.6f)
	//{
		uint3 coordinate = index1dTo3d(id3.x + offsetStart, highestVoxelResolution);

		float4 mixedColor =
			(RG0[uint3(coordinate.x - 1, coordinate.y, coordinate.z)] +
				RG0[uint3(coordinate.x + 1, coordinate.y, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y - 1, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y + 1, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y, coordinate.z - 1)] +
				RG0[uint3(coordinate.x, coordinate.y, coordinate.z + 1)]) / 6;

		RG1[coordinate.xyz].rgba = float4(mixedColor.rgb, RG0[coordinate.xyz].a);
	//}
}

// 1
[numthreads(256, 1, 1)]
void CSMain1(uint3 id3 : SV_DispatchThreadID)
{
		uint3 coordinate = index1dTo3d(id3.x + offsetStart, highestVoxelResolution);

		float4 mixedColor =
			(RG0[uint3(coordinate.x - 1, coordinate.y, coordinate.z)] +
				RG0[uint3(coordinate.x + 1, coordinate.y, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y - 1, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y + 1, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y, coordinate.z - 1)] +
				RG0[uint3(coordinate.x, coordinate.y, coordinate.z + 1)]) / 6;

		RG0[coordinate.xyz].rgba = float4(lerp(mixedColor.rgb, RG0[coordinate.xyz].rgb, 0.3), RG0[coordinate.xyz].a);
}

// 2
[numthreads(16, 16, 1)]
void CSMain2(uint3 id3 : SV_DispatchThreadID)
{
	//rng_state = id3.x * _Time;
	//float f0 = float(rand_lcg()) * (1.0 / 4294967296.0);

	//if (f0 > 0.1f)//&& f0 < 0.6f)
	//{
		uint3 coordinate = index1dTo3d(id3.x + offsetStart, highestVoxelResolution);

		float4 mixedColor =
			(RG0[uint3(coordinate.x - 1, coordinate.y, coordinate.z)] +
				RG0[uint3(coordinate.x + 1, coordinate.y, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y - 1, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y + 1, coordinate.z)] +
				RG0[uint3(coordinate.x, coordinate.y, coordinate.z - 1)] +
				RG0[uint3(coordinate.x, coordinate.y, coordinate.z + 1)]) / 6;

		RG1[coordinate.xyz] = lerp((mixedColor * 0.9f), RG1[coordinate.xyz], 0.5);
	//}
}


